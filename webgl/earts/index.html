<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js 地球</title>
    <script src="https://cdn.bootcss.com/three.js/r83/three.min.js"></script>
    <script src="./OrbitControls.js"></script>
</head>
<body>
    <!-- 3D视图的渲染容器 -->
    <canvas id="webglcanvas"></canvas>
    <script>
        let canvas;
        // camera 在哪个位置 角度
        // scene 场景 add 物件 
        // renderer 像视频一样渲染到canvas里去
        let camera, scene, renderer;
        let group;
        let mouseX = 0, mouseY = 0;
        // 屏幕的中心点就是 0 0 0 
        let windowHalfX = window.innerWidth / 2; 
        let windowHalfY = window.innerHeight / 2;

        init()
        render()
        function init() {
            canvas = document.getElementById('webglcanvas');
            // 透视相机
            // 第一个参数角度
            // 横拍 竖拍
            // near  far  最远能拍到多远
            camera = new THREE.PerspectiveCamera(60, 
            window.innerWidth/window.innerHeight, 1, 2000);
            camera.position.z = 500 // 摄像头离屏幕500 
            // 场景
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xffffff);
            // 男主角 女主角 .....
            group = new THREE.Group();
            scene.add(group);// 
            // 形状  + 材质 
            let loader = new THREE.TextureLoader(); 
            loader.load('land_ocean_ice_cloud_2048.jpg', function(texture) {
                let geometry = new THREE.SphereGeometry(200, 20, 20) // 球体
                let material = new THREE.MeshBasicMaterial({map: texture}) // 材质
                let mesh = new THREE.Mesh(geometry, material) 
                group.add(mesh)
            }, undefined, function (err) {
                console.error('图片加载失败', err)
            })


            renderer = new THREE.WebGLRenderer({
                canvas: canvas, // 输出到那里去
                antialias: true // 优化下， 抗锯齿
            })

            renderer.setSize(window.innerWidth, window.innerHeight);

            // 添加鼠标事件
            document.addEventListener('mousemove', onDocumentMouseMove, false);
            document.addEventListener('touchstart', onDocumentTouchStart, false);
            document.addEventListener('touchmove', onDocumentTouchMove, false);

            function onDocumentMouseMove(event) {
                mouseX = event.clientX - windowHalfX;
                mouseY = event.clientY - windowHalfY;
            }

            function onDocumentTouchStart(event) {
                if (event.touches.length === 1) {
                    event.preventDefault();
                    mouseX = event.touches[0].pageX - windowHalfX;
                    mouseY = event.touches[0].pageY - windowHalfY;
                }
            }

            function onDocumentTouchMove(event) {
                if (event.touches.length === 1) {
                    event.preventDefault();
                }
            }
        }

        function render() {
            requestAnimationFrame(render);
            group.rotation.y -= 0.005
            camera.position.x += (mouseX - camera.position.x) * 0.02;
            camera.position.y += (- mouseY - camera.position.y) * 0.02;
            camera.lookAt(scene.position);
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>

